# C++隐式类型转换的问题

## 什么是隐式类型转换?
> 可以用 单个形参来调用 的构造函数定义了从 形参类型 到 该类类型 的一个隐式转换。

&emsp;&emsp;隐式类型转换指的是, 假设一个类的构造函数只有一个参数(或者除第一个以外都有默认值); 我们可以进行一个从构造参数类型到该类类型的编译器自动转换

## 代码
```
class A
{
public:
    A(int a) {
        printf("%s\n", "构造函数");
    }
};

void fun(A a)
{

}

int main()
{
	A a = 3;
	fun(1);
	return 0;
}
```
`fun`函数的参数是`A`, 但是因为我们存在一个以`int`类型的构造函数, 所以会进行一次隐式转换
**这里的隐式转换并没有什么问题, 但是这种由编译器进行的隐式的转换, 如果非必要应当禁止**

## `explicit`关键字
```
class A
{
public:
    explicit A(int a) {
        printf("%s\n", "构造函数");
    }
};

void fun(A a)
{

}

int main()
{
	A a = 3;
	fun(1);
	return 0;
}
```
编译无法通过, 但是还是可以通过`A(1)`的方式创建

## 总结
* 1 `explicit`关键字仅能用于类内部的构造函数, 可以不加该关键字, 但是需要注意可能隐藏的问题
* 2 构造函数可以拥有多个形参, 但是必须可以只使用一个实参进行调用



## 扩展
&emsp;&emsp;在了解到拷贝构造函数和赋值运算符重载后, 我们应该会想到如果给一个函数传入一个类的实例的话, 比如`fun(A)`; 那么实际进行的是拷贝赋值还是调用的是赋值运算符呢? 我们知道C语言进行的就是简单的赋值.

**答案**: 拷贝构造函数; 事实上赋值运算符不会创建对象, 如果使用的是赋值运算符的话必然需要进行两次构造实例, 这是很不合理的
