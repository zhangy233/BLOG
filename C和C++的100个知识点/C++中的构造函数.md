# C++中的构造函数 & 析构函数

## 什么是构造函数?
&emsp;&emsp;一种特殊的方法, 在创建实例的时候初始化对象; 构造函数没有返回值, 在实例创建时隐式的调用
```
class A
{
	A(){}
	A(int a){}
	~A(){}
}
void main()
{
	A a1;
	A *a2 = new A();
	delete a2;	
}

```
在如上的代码中, `A(){}`就是构造函数, 在`A a1;`或者`A *a2 = new A();`这样创建实例的时候就会调用该函数.

ps: 构造函数可以重载多个, 传入不同的参数

## 什么是析构函数?
&emsp;&emsp;构造函数其实是为了初始化一些东西的, 比如数据库对象其连接的建立; 有了初始化那么必然就有销毁. 析构函数会在每次删除所创建的对象时调用(也是隐式的).

&emsp;&emsp;上一段代码`~A(){}`就是析构函数, 以波浪号为前缀; `delete a2`销毁`a2`, `main`函数退出时`a1`自动销毁(因为`a1`在栈中创建), 都会自动调用构造函数

## 拷贝构造函数
&emsp;&emsp;拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象

### 拷贝构造函数的用途?
```
struct A
{
	const char *str;
};

void test(A a)
{
	printf("%u\n", a.str);
}

int main()
{
	struct A b;
	char str[] = "hello";
	b.str = str;
	printf("%u\n", b.str);
	test(b);
	return 0;
}
```
**结果**:
```
6422034
6422034
```
在C语言中假设我们给一个函数传入一个对象(结构体), 我们知道实质进行了一次赋值操作`a = b`; 就像结果可以看到, 两个结构体实质指向了同一个地方, 那么假设情况复杂一点函数外的资源释放了呢(考虑到多线程等等), 函数内的该对象就不能在使用了。

&emsp;&emsp;在C++中我们就可以使用拷贝构造函数来解决这个问题

* 1 通过使用另一个同类型的对象来初始化新创建的对象。

* 2 复制对象把它作为参数传递给函数。

* 3 复制对象，并从函数返回这个对象。

### 常见形式(它是类的一个成员函数)
```
classname (const classname &obj) {
   // 构造函数的主体
}
```

## 赋值运算符重载
> 写到这里如果对C++了解的人一定会问, 拷贝构造函数和`=`重载的去区别呢?

### 赋值运算符重载格式?
```
void operator = (const classname &a){
	//主体
}
```


### 测试一下
```
class A
{
public:
    A(){printf("%s\n", "构造函数");}
    A(const A &a){printf("%s\n", "拷贝构造函数");}
    void operator = (const A &a)
    {
    	printf("%s\n", "赋值运算符重载");
    }
};


int main()
{
	A a;
	A b = a;			//用A来创造一个新的对象, 与b(a);相同
	A c;
	c = a;				//对一个已有的对象操作(重载函数中存在一个this指针)
	return 0;
}
```
**结果**:
```
构造函数
拷贝构造函数
构造函数
赋值运算符重载
```

&emsp;&emsp;注意赋值运算符重载不会创建新的对象, 它不是构造函数; 赋值运算符重载是对一个已有的对象进行一些操作。

